class group{
    constructor(layer){
        this.layer=layer
        this.storage={cards:[]}
        this.cards=[]
    }
    initial(){
        for(g=0;g<5;g++){
            this.add(1,0)
        }
        for(g=0;g<5;g++){
            this.add(2,0)
        }
    }
    add(type,level){
        this.cards.push(new card(this.layer,1200,475,type,level))
    }
    shuffle(){
        for(e=0,le=this.cards.length;e<le;e++){
            this.storage.cards.push(copyCard(this.cards[e]))
        }
        this.cards=[]
        while(this.storage.cards.length>0){
            e=floor(random(0,this.storage.cards.length))
            this.cards.push(copyCard(this.storage.cards[e]))
            this.storage.cards.splice(e,1)
        }
    }
    display(){
        for(g=0,lg=this.cards.length;g<lg;g++){
            this.cards[g].display()
        }
    }
    update(){
        for(g=0,lg=this.cards.length;g<lg;g++){
            if(this.cards[g].remove){
                this.cards.splice(g,1)
                g--
                lg--
            }
        }
    }
    updateHand(){
        for(g=0,lg=this.cards.length;g<lg;g++){
            this.cards[g].update()
            if(this.cards[g].position.x>g*80+120&&(this.cards[g].position.x>this.cards[max(0,g-1)].position.x+80||g==0)){
                this.cards[g].position.x-=20
            }
            if(inputs.rel.x>this.cards[g].position.x-this.cards[g].width/2&&(inputs.rel.x<this.cards[g].position.x+this.cards[g].width/2-40||inputs.rel.x<this.cards[g].position.x+this.cards[g].width/2&&g==lg-1)&&inputs.rel.y>300&&this.cards[g].position.y>325){
                this.cards[g].position.y-=20
            }else if(!(inputs.rel.x>this.cards[g].position.x-this.cards[g].width/2&&(inputs.rel.x<this.cards[g].position.x+this.cards[g].width/2-40||inputs.rel.x<this.cards[g].position.x+this.cards[g].width/2&&g==lg-1)&inputs.rel.y>300)&&this.cards[g].position.y<475){
                this.cards[g].position.y+=20
            }
        }
    }
    updateReserve(){
    }
    updateDeck(){
    }
}