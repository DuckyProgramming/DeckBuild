class group{
    constructor(layer,battle){
        this.layer=layer
        this.battle=battle
        this.storage={cards:[]}
        this.cards=[]
        this.select=false
        this.trigger=false
    }
    initial(){
        for(e=0;e<5;e++){
            this.add(2,0)
        }
        for(e=0;e<5;e++){
            this.add(2,0)
        }
    }
    add(type,level){
        this.cards.push(new card(this.layer,1200,500,type,level))
    }
    shuffle(){
        for(e=0,le=this.cards.length;e<le;e++){
            this.storage.cards.push(copyCard(this.cards[e]))
        }
        this.cards=[]
        while(this.storage.cards.length>0){
            e=floor(random(0,this.storage.cards.length))
            this.cards.push(copyCard(this.storage.cards[e]))
            this.storage.cards.splice(e,1)
        }
    }
    display(){ 
        for(e=0,le=this.cards.length;e<le;e++){
            this.cards[e].display()
        }
    }
    update(){
        for(e=0,le=this.cards.length;e<le;e++){
            if(this.cards[e].remove){
                this.cards.splice(e,1)
                e--
                le--
            }
            if(this.cards[e].discard){
                this.battle.discard.cards.push(copyCard(this.cards[e]))
                this.cards.splice(e,1)
                e--
                le--
            }
        }
    }
    updateHand(){
        for(e=0,le=this.cards.length;e<le;e++){
            this.cards[e].update(this.battle.mana)
            if((inputs.rel.x>this.cards[e].position.x-this.cards[e].width/2&&inputs.rel.x<this.cards[e].position.x+this.cards[e].width/2&&inputs.rel.y>350||this.cards[e].select)&&(!this.trigger||this.cards[e].trigger)&&this.cards[e].position.y>325){
                this.cards[e].position.y-=20
            }else if(!((inputs.rel.x>this.cards[e].position.x-this.cards[e].width/2&&inputs.rel.x<this.cards[e].position.x+this.cards[e].width/2&&inputs.rel.y>300||this.cards[e].select)&&(!this.trigger||this.cards[e].trigger))&&this.cards[e].position.y<500){
                this.cards[e].position.y+=20
            }
            if(this.cards[e].position.x>e*80+120&&(this.cards[e].position.x>this.cards[max(0,e-1)].position.x+80||e==0)){
                this.cards[e].position.x-=20
            }
        }
    }
    onClickHand(){
        if(!this.trigger){
            for(e=0,le=this.cards.length;e<le;e++){
                if(inputs.rel.x>this.cards[e].position.x-this.cards[e].width/2&&inputs.rel.x<this.cards[e].position.x+this.cards[e].width/2&&inputs.rel.y>this.cards[e].position.y-this.cards[e].height/2&&inputs.rel.y<this.cards[e].position.y+this.cards[e].height/2&&this.select&&this.cards[e].select&&this.battle.mana.main>=this.cards[e].cost){
                    this.trigger=true
                    this.cards[e].trigger=true
                    this.select=false
                    this.battle.attack.damage=this.cards[e].damage
                    this.battle.mana.main-=this.cards[e].cost
                    if(this.cards[e].target==0){
                        this.battle.attack.set(this.cards[e].type,this.cards[e].level)
                        this.cards[e].used=true
                        this.trigger=false
                    }
                }
                if(this.select&&this.cards[e].select){
                    this.cards[e].select=false
                    this.select=false
                }
                if(inputs.rel.x>this.cards[e].position.x-this.cards[e].width/2&&inputs.rel.x<this.cards[e].position.x+this.cards[e].width/2&&inputs.rel.y>350&&!this.select&&!this.cards[e].trigger){
                    this.cards[e].select=true
                    this.select=true
                }
            }
        }
    }
}